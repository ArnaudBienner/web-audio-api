<!DOCTYPE HTML>
<html>
<head>
<title>MediaStream Processing API</title>
<link rel="stylesheet" href="main.css">
</head>
<body>

<div class="head">
  <h1>MediaStream Processing API</h1>
  <h2>Draft Proposal</h2>
  <dl><dt>Editor:</dt><dd>Robert O'Callahan, Mozilla Corporation &lt;robert@ocallahan.org&gt;</dd>
</div>

<h2>Status of this Document</h2> 
<p>This document is a draft specification proposal with no official status. Send comments to the <a href="mailto:public-audio@w3.org">W3C audio mailing list</a>, or <a href="mailto:robert@ocallahan.org">Robert O'Callahan</a>. It is inappropriate to cite this document except as a work in progress.

<h2>Abstract</h2>

<p>A number of existing or proposed features for the Web platform deal with continuous real-time media:
<ul>
<li>HTML media elements
<li>Synchronization of multiple HTML media elements (e.g. proposed HTML MediaController)
<li>Capture and recording of local audio and video input (e.g. proposed HTML Streams)
<li>Peer-to-peer streaming of audio and video streams (e.g. proposed WebRTC and HTML Streams) 
<li>Advanced audio APIs that allow complex mixing and effects processing (e.g. Mozilla's AudioData, Chrome's AudioNode)
</ul>
Many use-cases require these features to work together. This proposal makes HTML Streams the foundation for integrated Web media processing by creating a mixing and effects processing API for HTML Streams.

<h2>Table of Contents</h2>

<ol id="toc">
  <li><a href="#introduction">1. Introduction</a>
  <ol>
    <li><a href="#scenarios">1.1. Scenarios</a>
  </ol>
  <li><a href="#mediastreams">2. MediaStreams</a>
  <ol>
    <li><a href="#scenarios">2.1. The Semantics Of MediaStreams</a>
    <li><a href="#buffer-formats">2.2. Buffer Formats</a>
    <li><a href="#mediastream-extensions">2.3. MediaStream Extensions</a>
  </ol>
  <li><a href="#media-elements">3. Media Elements</a>
  <li><a href="#stream-mixing-and-processing">4. Stream Mixing And Processing</a>
  <li><a href="#media-graph-considerations">5. Media Graph Considerations</a>
  <li><a href="#canvas-recording">6. Canvas Recording</a>
  <li><a href="#implementation-considerations">7. Implementation Considerations</a>
  <li><a href="#examples">8. Examples</a>
</ol>

<h2 id="introduction">1. Introduction</h2>

<p>The ideas here build on <a href="http://www.whatwg.org/specs/web-apps/current-work/complete/video-conferencing-and-peer-to-peer-communication.html">Ian Hickson's proposal for HTML Streams</a>, adding features partly inspired by <a href="https://wiki.mozilla.org/Audio_Data_API"> the Mozilla audio API</a> and <a href="http://chromium.googlecode.com/svn/trunk/samples/audio/specification/specification.html">the Chrome audio API</a>. Unlike previous audio API proposals, the API presented here integrates with proposed API for media capture from local devices, integrates with proposed API for peer-to-peer media streaming, handles audio and video in a unified framework, incorporates Worker-based Javascript audio processing, and specifies synchronization across multiple media sources and effects. The API presented here does not include a library of "native" effects; those should be added as a clean extension to StreamProcessor, perhaps as a "level 2" spec.

<p>The work here is nascent. Until a prototype implementation exists, this proposal is likely to be incomplete and possibly not even implementable.

<h3 id="scenarios">1.1. Scenarios</h3>

<p>These are concrete usage scenarios that have helped guide the design of the API. They are higher-level than use-cases.

<ol>
<li>Play video with processing effect applied to the audio track (e.g. high-pass filter)
<li>Play video with processing effects mixing in out-of-band audio tracks (in sync) (e.g. mixing in an audio commentary with audio ducking)
<li>Capture microphone input and stream it out to a peer with a processing effect applied to the audio (e.g. XBox 360 chat with voice distortion)
<li>Capture microphone input and visualize it as it is being streamed out to a peer and recorded (e.g. Internet radio broadcast)
<li>Capture microphone input, visualize it, mix in another audio track and stream the result to a peer and record (e.g. Internet radio broadcast)
<li>Receive audio streams from peers, mix them with spatialization effects, and play (e.g. live chat with spatial feature)
<li>Seamlessly chain from the end of one input stream to another (e.g. playlists, audio/video editing)
<li>Seamlessly switch from one input stream to another (e.g. adaptive streaming)
<li>Synthesize samples from JS data (e.g. game emulators or MIDI synthesizer)
<li>Trigger a sound sample to be played through the effects graph ASAP but without causing any blocking (e.g. game sound effects)
<li>Trigger a sound sample to be played through the effects graph at a given time (e.g. game sound effects)
<li>Capture video from a camera and analyze it (e.g. face recognition)
<li>Capture video and audio, record it to a file and upload the file (e.g. Youtube upload)
<li>Capture video from a canvas element, record it and upload (e.g. Screencast/"Webcast", or composite multiple video sources with effects into a single canvas then record)
</ol>

<h2 id="mediastreams">2. MediaStreams</h2>

<h3 id="the-semantics-of-mediastreams">2.1. The Semantics Of MediaStreams</h3>

<p>The description of MediaStreams here extends and must remain compatible with
<a href="http://www.whatwg.org/specs/web-apps/current-work/complete/video-conferencing-and-peer-to-peer-communication.html#stream-api">HTML MediaStreams</a>.

<p>A MediaStream contains video and audio tracks. Tracks can start and end at any time. Each track
contains a stream of audio or video data.

<p>Each MediaStream has an implicit "current time" identifying the point in the track(s) which is
currently playing. Normally current time advances in real time, but a MediaStream can be in a "blocked" state.
While blocked, the "current time" of the stream does not advance. MediaStreams and their tracks are not
seekable and their playback rate cannot be changed, so a group of MediaStreams that are all not blocked (or are
all blocked) will progress at the same rate. Blocking is used to maintain synchronization across
multiple streams when a stream needs to pause playback, e.g. because of a resource buffer underrun, or
because script explicitly paused playback.

<p>A MediaStream can be "ended". While it is ended, it is also blocked. An ended stream will not
normally produce data in the future (although it can if conditions change, e.g. if the source is reset somehow).

<div class="note">
<p>We do not allow streams to have independent timelines (e.g. no adjustable playback
rate or seeking within an arbitrary MediaStream), because that can lead to a single MediaStream being
consumed at multiple different "current times" simultaneously, which requires either unbounded buffering
or multiple internal decoders and buffers for a single MediaStream. It seems simpler and more
predictable for performance to require authors to create multiple streams (if necessary) and change
the playback rate in the original stream sources to handle such situations.
<p>For example, consider this hard case:
<ul>
<li>Three media element input streams: http://slow, http://fast, and http://fast2
<li>http://slow is mixed with http://fast
<li>http://fast is mixed with http://fast2
</ul>
Does the http://fast stream have to provide data at two different offsets? This spec's answer: no.
This leads us to the conclusion that if a stream feeds into a blocked mixer, then it itself must be
blocked. Since obviously a mixer with a blocked input must also be blocked, the entire graph of
connected streams block as a unit. This means that the mixing of http://fast and http://fast2 will
be blocked by delays in http://slow in the above scenario.
<p>Authors can avoid this by explicitly splitting streams that may need to progress at
different rates --- in the above case, by using two separate media elements each loading
http://fast. The HTML spec encourages implementations to share cached media data between
media elements loading the same URI.
</div>

<h3 id="buffer-formats">2.2 Buffer Formats</h3>

<p>This spec treats buffer formats for stream audio and video (e.g. sample rates and channels)
as an implementation detail, except where buffers are exposed to Workers for processing. Buffers are
implicitly resampled as necessary, e.g. when mixing streams with different formats. Authors can avoid
this resampling by ensuring their media resources and processing filters all use consistent buffer formats.

<p class="todo">However, suggested resampling algorithms will be provided in an appendix.

<h3 id="mediastream-extensions">2.3 MediaStream Extensions</h3>

<pre><code>partial interface MediaStream {
  readonly attribute double currentTime;

  ProcessedMediaStream createProcessor();
  ProcessedMediaStream createProcessor(in Worker worker);
};</code></pre>

<p>The <code>currentTime</code> attribute returns the amount of time that the stream has played since it was created.

<p>The <code>createProcessor()</code> method returns a new ProcessedMediaStream with this stream as its sole input.
The ProcessedMediaStream is configured with the default processing engine (see below).

<p>The <code>createProcessor(worker)</code> method returns a new MediaStreamProcessor with this stream as its sole input.
The ProcessedMediaStream is configured with <code>worker</code> as its processing engine.

<p class="todo">Add event handlers or callback functions for all ended and blocking state changes?

<h2 id="media-elements">3. Media Elements</h2>

<h3 id="media-element-extensions">3.1 Media Element Extensions</h3>

<p>We extend HTML media elements to produce and consume streams. When an HTML media element
produces a stream, it acts as a resource loader and control mechanism; the stream consists of whatever the
media element is currently playing. When a media element consumes a stream, it acts a playback
mechanism for the stream.

<pre><code>partial interface HTMLMediaElement {
  readonly attribute MediaStream stream;
 
  MediaStream captureStream();
  attribute boolean captureAudio;

  attribute any src;
};</pre></code>

<p>The <code>stream</code> attribute returns a stream which always plays whatever the element is playing. The
stream is blocked while the media element is not playing, and conversly whenever the stream is blocked the
element's playback is also blocked. The <code>stream</code> attribute for a given element always returns
the same stream. When the stream changes to blocked, we fire the <code>waiting</code> event for the media element,
and when it changes to unblocked we fire the <code>playing</code> event for the media element.

<p class="XXX">Currently the HTML media element spec says that <code>playing</code> would fire on an element
that is able to play except that a downstream <code>MediaController</code> is blocked. This is incompatible
with the above. I think that part of the HTML media spec should be changed so that only elements that are actually
going to play fire <code>playing</code>.

<p>While the <code>captureAudio</code> attribute is true, the element does not produce direct audio output.
Audio output is still sent to <code>stream</code>. This attribute is NOT reflected into the DOM. It
is initially false.

<p>The <code>captureStream()</code> method returns the same stream as <code>stream</code>, but also
sets the <code>captureAudio</code> attribute to true.

<p>The <code>src</code> attribute is extended to allow it to be set to a <code>MediaStream</code>.

<p>The <code>URL.createObjectURL(stream)</code> method defined for HTML MediaStreams can create a URL to be
used as a source for a media element.

<h2 id="stream-mixing-and-processing">4. Stream Mixing And Processing</h2>

<h3 id="time-varying-attributes">4.1 Time-varying Attributes</h3>

<p>Attributes controlling media stream processing can be set directly. Attribute changes take effect immediately insofar as they are reflected by attribute getters and other DOM methods. However, to avoid race conditions and unexpected glitches, attribute changes that affect stream output do not immediately cause changes in stream data processing. Instead, the attribute changes that occur between one <em>stable state</em> and the next (as defined in HTML) must be batched together and made to take effect on media processing <em>simultaneously</em> at some point in the future; user-agents should apply the changes as early as possible (but without causing underruns in buffered media data being consumed by output devices, of course).

<div class="example">Thus the following script would never cause an interruption in audio output, since no stable state occurs between the two volume changes:
<pre><code>  stream.inputs[0].volume = 0;
  if (needToPlay()) {
    stream.inputs[0].volume = 1.0;
  }</code></pre>
</div>

<p class="todo">Specify exactly which attributes (and methods) are subject to this regime, including
attributes and methods already defined in HTML for media elements etc.

<p>To enable precise control over the timing of attribute changes, many attributes can be set using a
"timed setter" method taking a <code>startTime</code> parameter. The user-agent will attempt to make the change take
effect at the given <code>startTime</code> --- certainly no earlier, but possibly later if <code>startTime</code> is too close to the stream's current time. <code>startTime</code> is always specified in the same
timeline as the stream's current time, i.e., the amount of time the stream has played since it was created. <code>startTime</code>
is optional; if ommitted, the stream's current time is used.

<p>Using the setter method never changes the observed attribute value immediately. The delayed changes always take effect, from a script's point of view, during a <em>stable state</em>. Changes to other script-observable
state such as a <code>MediaStream</code>'s <code>currentTime</code> also take effect during a <em>stable state</em>, and all these changes are kept in sync, so that as a script runs it always sees a consistent snapshot
of <code>MediaStream</code> state.

<p>Multiple pending changes to an attribute are allowed. Calling the setter method with
<code>startTime</code> T sets the value of the attribute for all times T' >= T to the desired value. Therefore
by calling the setter method multiple times with increasing <code>startTime</code>, a series of change requests
can be built up. Setting the attribute directly sets the value of the attribute for all future times, wiping
out any pending setter method requests.

<h3 id="processedmediastream">4.2 ProcessedMediaStream</h3>

<p>A <code>ProcessedMediaStream</code> combines zero or more input streams and applies some processing to
combine them into a single output stream.

<pre><code>[Constructor]
interface ProcessedMediaStream : MediaStream {
  readonly attribute MediaInput[] inputs;
  MediaInput addInput(in MediaStream input);

  attribute DOMString ending;

  attribute any params;
  void setParams(in any params, in optional double startTime);

  attribute Worker worker;
  void setWorker(in Worker worker, in optional double startTime);
};</pre></code>

<p>The <code>inputs</code> attribute returns an array of <code>MediaInput</code>s, one for
each stream currently configured as an input to the <code>ProcessedMediaStream</code>. (A stream can be used as multiple inputs to the same <code>ProcessedMediaStream</code>.) It is
initially empty if constructed via the <code>ProcessedMediaStream()</code> constructor, or
contains a single element if constructed via <code>MediaStream.createProcessor</code>.

<p>The <code>addInput(input)</code> method adds a new <code>MediaInput</code> to the end of the
<code>inputs</code> array, whose input stream is <code>input</code>.

<p>The <code>ending</code> attribute controls when the stream ends. When the value is "all", the stream is in the ended
state when all active inputs are ended (including if there are no active inputs). When the value is "any",
the stream is in the ended state when any active input is ended, or if there are no active inputs. Otherwise the
stream is never ended. The initial value is "all".

<p>The <code>params</code> attribute and the <code>setParams(params, startTime)</code> timed setter method set the paramters for this stream. On setting, a <em>structured clone</em> of this object is made. The clone is sent to
the <code>worker</code> during media processing. On getting, a fresh clone is returned.

<p>The <code>worker</code> attribute and <code>setWorker</code> timed setter method set the current worker
for the <code>ProcessedMediaStream</code> (see below).

<p>While <code>worker</code> is null, a <code>ProcessedMediaStream</code> produces output as follows:
<ul>
<li>If no active input has an audio track, the output has no audio track. Otherwise, the output has a single
audio track whose metadata (<code>id</code>, <code>kind</code>, <code>label</code>, and <code>language</code>)
is equal to that of the audio track for the last active input that has an audio track. The output audio track
is produced by adding the samples of the audio tracks of the active inputs together.
<li>If no active input has a video track, the output has no video track. Otherwise, the output has a single
video track whose metadata (<code>id</code>, <code>kind</code>, <code>label</code>, and <code>language</code>)
is equal to that of the video track for the last active input that has a video track. The output video track
is produced by compositing together all the video frames from the video tracks of the active inputs, with the video
frames from higher-numbered inputs on top of the video frames from lower-numbered inputs; each
video frame is letterboxed to the size of the video frame for the last active input that has a video track.
<p class="note">This means if the last input's video track is opaque, the video output is simply the video track of the last input.
</ul>

<p class="todo">Need to add an additional attribute to configure "built-in" processing effects.

<h3 id="mediainput">4.3 MediaInput</h3>

<p>A <code>MediaInput</code> object controls how an input stream contributes to the combined stream. 

<pre><code>[Constructor]
interface MediaInput {
  readonly attribute MediaStream stream;

  attribute double volume;
  void setVolume(in double volume, in optional double startTime, in optional double duration);

  attribute boolean enabled;
  void setEnabled(in boolean enabled, in optional double startTime);

  attribute boolean blockInput;
  attribute boolean blockOutput;

  attribute any params;
  void setParams(in any params, in optional double startTime);

  void remove();
};</pre></code>

<p>The <code>stream</code> attribute returns the <code>MediaStream</code> connected to this input.
The input stream is treated as having at most one audio and/or video track; all enabled audio tracks are mixed
together and the rest are dropped, and all video tracks other than the selected video track are dropped.

<p class="todo">Add additional API to select particular tracks.

<p>The <code>volume</code> volume attribute and the <code>setVolume</code> timed setter method
control the input volume; the input stream's audio is multiplied by this volume before
being processed. The <code>setVolume</code> method takes an additional <code>duration</code> parameter; when greater
than zero, the volume is changed gradually from the value just before <code>startTime</code> to
the new value over the given duration. The transition function is chosen so that if one stream changes from V1 to V2
and another stream changes from V2 to V1 over the same interval, the sum of the volumes at each point in
time is V1 + V2. This attribute is initially 1.0.

<p class="todo">Specify the exact transition function.

<p>The <code>enabled</code> attribute and <code>setEnabled</code> timed setter method control whether this
input is used for processing. When false, the input is completely ignored and is not presented to the processing
Worker. This attribute is initially true.

<p>An input is <em>active</em> if it is enabled and not blocked.

<p>The <code>blockInput</code> and <code>blockOutput</code> attributes control
how the blocking status of the input stream is related to the blocking status of the output stream.
When <code>blockOutput</code> is true, if the input stream is blocked then the output stream must be blocked.
When false, while the input is blocked and the output is not, the input will be treated as
having no tracks. When <code>blockInput</code> is true, if the output is blocked or the input is disabled,
then the input stream must be blocked. When false, while the output is blocked and the input is not, the input will simply be discarded.
These attributes are initially true.ao

<p>The <code>params</code> attribute and the <code>setParams(params, startTime)</code> timed setter method set the paramters for this input. On setting, a <em>structured clone</em> of this object is made. The clone is sent to
the <code>worker</code> during media processing. On getting, a fresh clone is returned.

<p>The <code>remove()</code> method removes this <code>MediaInput</code> from the inputs array of its owning
<code>ProcessedMediaStream</code>. The <code>MediaInput</code> object is no longer used; its attributes retain their
current values and do not change unless explicitly set. All method calls are ignored.

<h3 id="worker-processing">4.4 Worker Processing</h3>

<p>While a <code>ProcessedMediaStream</code>'s <code>worker</code> is non-null, input stream data is fed into
the worker by dispatching <code>onmediastream</code> callbacks. Each <code>onmediastream</code> callback
takes a <code>MediaStreamEvent</code> parameter. A <code>MediaStreamEvent</code> provides audio sample
buffers for each input stream; the event callback can write audio output buffers and a list of output video frames.
If the callback does not output audio, default audio output is automatically generated by adding together the input
audio buffers. The <code>MediaStreamEvent</code> gives access to the parameters object for each input stream
and the parameters object for the output stream.

<p class="todo">Currently <code>MediaStreamEvent</code> does not offer access to video data. This should be added later.

<pre><code>partial interface DedicatedWorkerGlobalScope {
  attribute Function onmediastream;
  attribute boolean streamVariableAudioFormats;
  attribute double streamRewindMax;
};</pre></code>

<p>Note that a <code>ProcessedMediaStream</code>'s <code>worker</code> cannot be a
<code>SharedWorker</code>. This ensures that the worker can run in the same process as the page in multiprocess browsers, so media streams can be confined to a single process.

<p>The <code>onmediastream</code> attribute is the function to be called whenever stream data needs to be processed.
 
<p>While <code>streamVariableAudioFormats</code> is false (the default), when the event handler fires, the UA will convert all the input audio buffers to a single common format before presenting them to the event handler. Typically the UA would choose the highest-fidelity format from among the inputs, to avoid lossy conversion. If 
<code>streamVariableAudioFormats</code> was false for the previous invocation of the event handler, the UA also ensures that the format stays the same as the format used by the previous invocation of the handler.

<p>To support graph changes with low latency, we might need to throw out processed samples that have already been buffered and reprocess them. The <code>streamRewindMax</code> attribute indicates how far back, in seconds, the worker supports rewinding. The default value of <code>streamRewindMax</code> is zero; workers that support rewinding need to opt into it.

<pre><code>interface MediaStreamEvent {
  readonly attribute double rewind;
  readonly attribute double inputTime;

  readonly attribute any params;
  readonly attribute double paramsStartTime;

  readonly attribute MediaInputBuffer inputs[];

  void writeAudio(in long sampleRate, in short channels, in Float32Array data);
};</pre></code>

<p>The <code>rewind</code> attribute indicates how far back in the stream's history we have moved between the
previous event and this event (normally zero). It is a non-negative value less than or equal to the value of <code>streamRewindMax</code>on entry to the event handler.

<p>The <code>inputTime</code> attribute returns the duration of the input that has been consumed since this worker
was set as the worker for the <code>ProcessedMediaStream</code>.

<p>The <code>params</code> attribute provides a structured clone of the parameters object set by
<code>ProcessedMediaStream.setParams</code>. The same object is returned in each event, except when the object has
been changed by <code>setParams</code> between events. <p>The <code>paramsStartTime</code> attribute returns the first time (measured in duration of input consumed) that this <code>params</code> object was set.

<p class="note">Note that the parameters objects are constant over the duration of the inputs presented in the
event. Frequent changes to parameters will reduce the length of the input buffers that can be presented to
the worker.

<p><code>inputs</code> provides access to <code>MediaStreamBuffers</code> for each active input stream
(in the same order as those streams appear in the <code>ProcessedMediaStream.inputs</code> array).

<p><code>writeAudio(sampleRate, channels, data)</code> writes audio data to the stream output.
The output has a single audio track. If there is an active input with an audio track, then the metadata for the output audio track is set to the metadata for the audio track of the last active input that has an audio track, otherwise the output audio track's <code>kind</code> is "main" and the other metadata attriutes are the empty string. The data for the output audio track is the concatenation of the
inputs to each <code>writeAudio</code> call before the event handler returns. <code>sampleRate</code> is samples per second; <code>data</code> contains one float per channel per sample, so the <code>data</code> array length must be a multiple of <code>channels</code>. The channel mapping is as defined in the Vorbis specification.

<p>It is permitted to write less audio than the duration of the inputs (including none). This indicates latency in the filter. Normally the user-agent will dispath another event to provide
more input until the worker starts producing output. It is also permitted to write more audio than the duration of the inputs, for example if there are no inputs.
Filters with latency should respond to an event with no inputs by writing out some of their buffered data; the user-agent
is draining them.

<p class="note">A synthesizer with no inputs can output as much data as it wants; the UA will buffer data and fire events as necessary. Filters that misbehave, e.g. by continuously writing zero-length buffers, will cause the stream to block due to an underrun.

<p>If <code>writeAudio</code> is not called during the event handler, then the output audio track is computed as if
there was no worker (see above).

<p>The output video track is computed as if there was no worker (see above).

<p class="todo">This will change when we add video processing.

<pre><code>interface MediaInputBuffer {
  readonly attribute any params;
  readonly attribute double paramsStartTime;

  readonly attribute long audioSampleRate;
  readonly attribute short audioChannels;
  reaodnly attribute long audioLength;
  readonly attribute Float32Array audioSamples;
};</pre></code>

<p>The <code>params</code> attribute provides a structured clone of the parameters object set by
<code>MediaInput.setParams</code>. The same object is returned in each event, except when the object has
been changed by <code>setParams</code> between events. <p>The <code>paramsStartTime</code> attribute returns the first time (measured in duration of input consumed) that this <code>params</code> object was set.

<p><code>audioSampleRate</code> and <code>audioChannels</code> represent the format of the samples.
<code>audioSampleRate</code> is the number of samples per second. <code>audioChannels</code> is the number of channels; the channel mapping is as defined in the Vorbis specification.

<p><code>audioLength</code> is the number of samples per channel.

<p><code>audioSamples</code> gives access to the audio samples for each input stream. The array length will be <code>audioLength</code> multiplied by <code>audioChannels</code>. The samples are floats ranging from -1 to 1, laid out non-interleaved, i.e. consecutive segments of <code>audioLength</code> samples each. The durations of the input buffers for the input streams will be equal (or as equal as possible if there are varying sample rates). The <code>audioSamples</code> object will be a fresh object in each event.

<p>For inputs with no audio track, <code>audioChannels</code> will be zero, and the <code>audioSamples</code> array will be empty, unless <code>streamVariableAudioFormats</code> is false and some input stream has an audio track; in that case
<code>audioChannels</code>, <code>audioLength</code> and <code>audioSampleRate</code> will match the input stream that
has an audio track, and the <code>audioSamples</code> array will be all zeroes.

<h2 id="media-graph-considerations">5. Media Graph Considerations</h2>

<h3 id="cycles">5.1. Cycles</h3>

<p>While a <code>ProcessedMediaStream</code> has itself as a direct or indirect input stream (considering only enabled inputs), it is blocked.

<h3 id="blocking">5.2. Blocking</h2>

<p>At each moment, every stream should not be blocked except as explicitly required by this specification.

<h2 id="canvas-recording">6. Canvas Recording</h2>

<p>To enable video synthesis and some easy kinds of video effects we can record the contents of a canvas:

<pre><code>partial interface HTMLCanvasElement {
  readonly attribute MediaStream stream;
};</pre></code>

<p>The <code>stream</code> attribute is a stream containing a video track with the "live" contents of the canvas as video frames whose size is the size of the canvas, and no audio track. It always returns the same stream for a given element.

<h2 id="implementation-considerations">7. Implementation Considerations</h2>

<p class="todo">Here will be some non-normative implementation suggestions.

<h2 id="examples">8. Examples</h2>

<p class="todo">Add Worker scripts for these examples.

<ol>
<li>Play video with processing effect applied to the audio track 

<pre><code>&lt;video src="foo.webm" id="v" controls&gt;&lt;/video&gt;
&lt;audio id="out" autoplay&gt;&lt;/audio&gt;
&lt;script&gt;
document.getElementById("out").src =
   document.getElementById("v").captureStream().createProcessor(new Worker("effect.js"));
&lt;/script&gt;</pre></code>

<li>Play video with processing effects mixing in out-of-band audio tracks (in sync)

<pre><code>&lt;video src="foo.webm" id="v"&gt;&lt;/video&gt;
&lt;audio src="back.webm" id="back"&gt;&lt;/audio&gt;
&lt;audio id="out" autoplay&gt;&lt;/audio&gt;
&lt;script&gt;
  var mixer = document.getElementById("v").captureStream().createProcessor(new Worker("audio-ducking.js"));
  mixer.addInput(document.getElementById("back").captureStream());
  document.getElementById("out").src = mixer;
  function startPlaying() {
    document.getElementById("v").play();
    document.getElementById("back").play();
  }
  // MediaController is a more convenient API because it ties together control of the elements,
  // but using streams is more flexible (e.g. they can be seeked to different offsets).
&lt;/script&gt;</pre></code>

<li>Capture microphone input and stream it out to a peer with a processing effect applied to the audio 

<pre><code>&lt;script&gt;
  navigator.getUserMedia('audio', gotAudio);
  function gotAudio(stream) {
    peerConnection.addStream(stream.createProcessor(new Worker("effect.js")));
  }
&lt;/script&gt;</pre></code>

<li>Capture microphone input and visualize it as it is being streamed out to a peer and recorded 

<pre><code>&lt;canvas id="c"&gt;&lt;/canvas&gt;
&lt;script&gt;
  navigator.getUserMedia('audio', gotAudio);
  var streamRecorder;
  function gotAudio(stream) {
    var worker = new Worker("visualizer.js");
    var processed = stream.createProcessor(worker);
    worker.onmessage = function(event) {
      drawSpectrumToCanvas(event.data, document.getElementById("c"));
    }
    streamRecorder = processed.record();
    peerConnection.addStream(processed);
  }
&lt;/script&gt;</pre></code>

<li>Capture microphone input, visualize it, mix in another audio track and stream the result to a peer and record 

<pre><code>&lt;canvas id="c"&gt;&lt;/canvas&gt;
&lt;audio src="back.webm" id="back"&gt;&lt;/audio&gt;
&lt;script&gt;
  navigator.getUserMedia('audio', gotAudio);
  var streamRecorder;
  function gotAudio(stream) {
    var worker = new Worker("visualizer.js");
    var processed = stream.createProcessor(worker);
    worker.onmessage = function(event) {
      drawSpectrumToCanvas(event.data, document.getElementById("c"));
    }
    var mixer = processed.createProcessor();
    mixer.addInput(document.getElementById("back").captureStream());
    streamRecorder = mixer.record();
    peerConnection.addStream(mixer);
  }
&lt;/script&gt;</pre></code>

<li>Receive audio streams from peers, mix them with spatialization effects, and play 

<pre><code>&lt;audio id="out" autoplay&gt;&lt;/audio&gt;
&lt;script&gt;
  var worker = new Worker("spatializer.js");
  var spatialized = stream.createProcessor(worker);
  peerConnection.onaddstream = function (event) {
    spatialized.addInput(event.stream).params = {x:..., y:..., z:...};
  };
  document.getElementById("out").src = spatialized;
&lt;/script&gt;</pre></code>

<li>Seamlessly chain from the end of one input stream to another 

<p class="note">This method requires that you know each stream's duration, which is a bit unfortunate.
To get around that we'd need new API, perhaps a new kind of ProcessedMediaStream that plays streams in
serial.

<pre><code>&lt;audio src="in1.webm" id="in1" preload&gt;&lt;/audio&gt;
&lt;audio src="in2.webm" id="in2"&gt;&lt;/audio&gt;
&lt;audio id="out" autoplay&gt;&lt;/audio&gt;
&lt;script&gt;
  var in1 = document.getElementById("in1");
  in1.onloadeddata = function() {
    var mixer = in1.captureStream().createProcessor();
    var in2 = document.getElementById("in2");
    var input2 = mixer.addInput(in2.captureStream());
    input2.enabled = false;
    input2.setEnabled(true, in1.duration);
    in1.onended = function() { mixer.inputs[0].remove(); };
    document.getElementById("out").src = mixer;
    in1.play();
  }
&lt;/script&gt;</pre></code>

<li>Seamlessly switch from one input stream to another, e.g. to implement adaptive streaming 

<p class="note">There are two ways to implement seamless switching: seek the second resource to before the
current time and then run the decoder faster than real-time to catch up to the first resource's play point, or
seek the second resource to after the current time and enable it when the first resource catches up to the seek
point. The first is more robust if the seek takes unexpectedly long, but the second is less demanding on the
decoder. Only the second method is currently implementable with this API (since by design there is no way to drive MediaStreams faster than real-time). If we want to support the first method as well, the right way would be to
add API to media elements to let them seek to synchronize with a given MediaStream.

<pre><code>&lt;audio src="in1.webm" id="in1" preload&gt;&lt;/audio&gt;
&lt;audio src="in2.webm" id="in2"&gt;&lt;/audio&gt;
&lt;audio id="out" autoplay&gt;&lt;/audio&gt;
&lt;script&gt;
  var stream1 = document.getElementById("in1").captureStream();
  var mixer = stream1.createProcessor();
  document.getElementById("out").src = mixer;
  function switchStreams() {
    var in2 = document.getElementById("in2");
    in2.currentTime = in1.currentTime + 10; // arbitrary, but we should be able to complete the seek within this
    var input2 = mixer.addInput(in2.captureStream());
    // in2 will be blocked until the input port is enabled
    input2.enabled = false;
    input2.setEnabled(true, mixer.currentTime + 10);
    mixer.inputs[0].setEnabled(false, mixer.currentTime + 10);
    in2.onplaying = function() { mixer.inputs[0].remove(); };
  }
&lt;/script&gt;</pre></code>

<li>Synthesize samples from JS data 

<pre><code>&lt;audio id="out" autoplay&gt;&lt;/audio&gt;
&lt;script&gt;
  document.getElementById("out").src =
    new ProcessedMediaStream(new Worker("synthesizer.js"));
&lt;/script&gt;</pre></code>

<li>Trigger a sound sample to be played through the effects graph ASAP but without causing any blocking 

<pre><code>&lt;script&gt;
  var effectsMixer = ...;
  function playSound(src) {
    var audio = new Audio(src);
    audio.oncanplaythrough = new function() {
      var stream = audio.captureStream();
      effectsMixer.addInput(stream).blockOutput = false;
      stream.onended = function() { effectsMixer.removeStream(stream); }
      audio.play();
    }
  }
&lt;/script&gt;</pre></code>

<li>Trigger a sound sample to be played through the effects graph in five seconds

<pre><code>&lt;script&gt;
  var effectsMixer = ...;
  var audio = new Audio(...);
  function triggerSound() {
    var audio = new Audio(...);
    var stream = audio.captureStream();
    audio.play();
    var input = effectsMixer.addInput(stream);
    input.enabled = false;
    input.setEnabled(true, effectsMixer.currentTime + 5);
    stream.onended = function() { effectsMixer.removeStream(stream); }
  }
&lt;/script&gt;</pre></code>

<li>Capture video from a camera and analyze it (e.g. face recognition)

<pre><code>&lt;script&gt;
  navigator.getUserMedia('video', gotVideo);
  function gotVideo(stream) {
    stream.createProcessor(new Worker("face-recognizer.js"));
  }
&lt;/script&gt;</pre></code>

<li>Capture video, record it to a file and upload the file (e.g. Youtube)

<pre><code>&lt;script&gt;
  navigator.getUserMedia('video', gotVideo);
  var streamRecorder;
  function gotVideo(stream) {
    streamRecorder = stream.record();
  }
  function stopRecording() {
    streamRecorder.getRecordedData(gotData);
  }
  function gotData(blob) {
    var x = new XMLHttpRequest();
    x.open('POST', 'uploadMessage');
    x.send(blob);
  }
&lt;/script&gt;</pre></code>

<li>Capture video from a canvas, record it to a file then upload

<pre><code>&lt;canvas width="640" height="480" id="c"&gt;&lt;/canvas&gt;
&lt;script&gt;
  var canvas = document.getElementById("c");  
  var streamRecorder = canvas.stream.record();
  function stopRecording() {
    streamRecorder.getRecordedData(gotData);
  }
  function gotData(blob) {
    var x = new XMLHttpRequest();
    x.open('POST', 'uploadMessage');
    x.send(blob);
  }
  var frame = 0;
  function updateCanvas() {
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, 640, 480);
    ctx.fillText("Frame " + frame, 0, 200);
    ++frame;
  }
  setInterval(updateCanvas, 30);
&lt;/script&gt;</pre></code>
</ol>

<h1>Related Work</h1>

<ul>
<li><a href="https://wiki.mozilla.org/RTCStreamAPI">W3C-RTC charter</a> (Harald et. al.)
<li><a href="http://www.whatwg.org/specs/web-apps/current-work/complete/video-conferencing-and-peer-to-peer-communication.html">WhatWG proposal (Ian Hickson et. al.)</a>
<li><a href="http://chromium.googlecode.com/svn/trunk/samples/audio/specification/specification.html">Chrome audio API</a>
<li><a href="https://wiki.mozilla.org/Audio_Data_API">Mozilla audio API</a>
<li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#mediacontroller">WhatWG MediaController API</a>
</body>
</html>
